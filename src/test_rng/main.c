#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define NITER 4
#define RAN_INIT 1337

/* From Press et al., Numerical Recipes in C:
 * '“Pseudo-DES” hashing of the 64-bit word (lword,irword). Both 32-bit
 * arguments are re- turned hashed on all bits.' */
void psdes(unsigned long *lword, unsigned long *irword)
{
  unsigned long i,ia,ib,iswap,itmph=0,itmpl=0; 
  static unsigned long c1[NITER]={ 0xbaa96887L, 0x1e17d32cL, 0x03bcdc3cL, 0x0f33d1b2L}; 
  static unsigned long c2[NITER]={ 0x4b0f3b58L, 0xe874f0c3L, 0x6955c5a6L, 0x55a7ca46L};
  for (i=0;i<NITER;i++) {
    /* Perform niter iterations of DES logic, using a simpler
     * (non-cryptographic) nonlinear func- tion instead of DES’s. */
    ia=(iswap=(*irword)) ^ c1[i];
    itmpl = ia & 0xffff;
    itmph = ia >> 16;
    ib=itmpl*itmpl+ ~(itmph*itmph); 
    *irword=(*lword) ^ (((ia = (ib >> 16) |
            ((ib & 0xffff) << 16)) ^ c2[i])+itmpl*itmph); 
    *lword=iswap;
  }
}

/* From Press et al., Numerical Recipes in C:
 * 'Returns a uniform random deviate in the range 0.0 to 1.0, generated by
 * pseudo-DES (DES- like) hashing of the 64-bit word (idums,idum), where idums
 * was set by a previous call with negative idum. Also increments idum. Routine
 * can be used to generate a random sequence by successive calls, leaving idum
 * unaltered between calls; or it can randomly access the nth deviate in a
 * sequence by calling with idum = n. Different sequences are initialized by
 * calls with differing negative values of idum.' */
float ran4(long *idum) {
  void psdes(unsigned long *lword, unsigned long *irword);
  unsigned long irword,itemp,lword;
  static long idums = 0;
  /* The hexadecimal constants jflone and jflmsk below are used to produce a floating number between 1. and 2. by bitwise masking. They are machine-dependent. See text. */
#if defined(vax) || defined(_vax_) || defined(__vax__) || defined(VAX) 
  static unsigned long jflone = 0x00004080;
  static unsigned long jflmsk = 0xffff007f;
#else
  static unsigned long jflone = 0x3f800000; 
  static unsigned long jflmsk = 0x007fffff;
#endif
  if (*idum < 0) { 
    idums = -(*idum); 
    *idum=1;
  }
  irword=(*idum);
  lword=idums;
  psdes(&lword,&irword); 
  itemp=jflone | (jflmsk & irword); 
  ++(*idum);
  return (*(float *)&itemp)-1.0;
}

/* Modification of pdes; removes static variables */
void my_psdes(unsigned long *lword, unsigned long *irword)
{
  unsigned long i,ia,ib,iswap,itmph=0,itmpl=0; 
  const unsigned long c1[NITER]={ 0xbaa96887L, 0x1e17d32cL, 0x03bcdc3cL, 0x0f33d1b2L}; 
  const unsigned long c2[NITER]={ 0x4b0f3b58L, 0xe874f0c3L, 0x6955c5a6L, 0x55a7ca46L};
  for (i=0;i<NITER;i++) {
    ia=(iswap=(*irword)) ^ c1[i];
    itmpl = ia & 0xffff;
    itmph = ia >> 16;
    ib=itmpl*itmpl+ ~(itmph*itmph); 
    *irword=(*lword) ^ (((ia = (ib >> 16) |
            ((ib & 0xffff) << 16)) ^ c2[i])+itmpl*itmph); 
    *lword=iswap;
  }
}

/* Modification of ran4; removes static variables */
float my_ran4(const long seed, const long n) {
  unsigned long irword,itemp,lword;
  /* The hexadecimal constants jflone and jflmsk below are used to produce a floating number between 1. and 2. by bitwise masking. They are machine-dependent. See text. */
  const unsigned long jflone = 0x3f800000; 
  const unsigned long jflmsk = 0x007fffff;
  irword = n;
  lword = seed;
  my_psdes(&lword,&irword); 
  itemp=jflone | (jflmsk & irword); 
  return (*(float *)&itemp)-1.0;
}

/* A stateless random number generator, based on algorithms from Numerical Recipes.
 * Produces the n-th element of a sequence that was initially seeded with 'seed'.
 * The bitmasks assume unsigned long ints are 32 bits; and that 32-bit floats
 * follow IEEE representation.  */
float rn_s(const long seed, const long n) {
  // For pdes
  unsigned long i,ia,ib,iswap,itmph=0,itmpl=0; 
  const unsigned long c1[4]={ 0xbaa96887L, 0x1e17d32cL, 0x03bcdc3cL, 0x0f33d1b2L}; 
  const unsigned long c2[4]={ 0x4b0f3b58L, 0xe874f0c3L, 0x6955c5a6L, 0x55a7ca46L};
  // For ran4
  unsigned long irword,itemp,lword;
  const unsigned long jflone = 0x3f800000; 
  const unsigned long jflmsk = 0x007fffff;
  irword = n;
  lword = seed;
  // Run pdes
  for (i=0; i<4; i++) {
    ia = (iswap = irword) ^ c1[i];
    itmpl = ia & 0xffff;
    itmph = ia >> 16;
    ib = itmpl*itmpl+ ~(itmph*itmph); 
    irword = lword ^ (((ia = (ib >> 16) |
            ((ib & 0xffff) << 16)) ^ c2[i])+itmpl*itmph); 
    lword = iswap;
  }
  itemp=jflone | (jflmsk & irword); 
  return (*(float *)&itemp)-1.0;
}

int main(int argc, char *argv[]) {
  int n_values = argc > 1 ? atoi(argv[1]) : 10000000;
  long seed = -RAN_INIT;

  for (int i=1; i<n_values; i++) {

    if (i % 1000 == 0) {
      printf("Finished %d iterations.\r", i);
    }

    float a = ran4(&seed);
    // float b = my_ran4(RAN_INIT, i);
    float b = rn_s(RAN_INIT, i);

    if ( a != b) {
      printf("Finished %d iterations.\n", i);
      printf("RNGs differ at %d iterations (%0.6f != %0.6f.\n", i, a, (float) b);
      return 1;
    }
  }

  printf("Finished %d iterations.\n", n_values);
  printf("RNGs were identical after %d iterations.\n", n_values);
  return 0;
}





